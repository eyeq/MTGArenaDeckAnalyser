<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>MTG Arena Deck Analyser</title>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>

    <link rel="stylesheet" href="https://fonts.sandbox.google.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body>
    <div>
        <textarea id="input" rows="20" cols="45" placeholder="Export a Deck from MTG Arena" onchange="read();"></textarea>
    </div>
    <br>
    <br>

    <div id="format" style="display: inline-block;"></div>
    <br>
    <br>

    <div id="symbol" style="display: inline-block;"></div>
    <div id="type" style="display: inline-block;"></div>
    <br>
    <br>

    <div id="rarity" style="display: inline-block;"></div>
    <br>
    <br>

    <div id="cmc" style="display: inline-block;"></div>
    <br>
    <br>

    <div>
        <input type="radio" id="s" name="size" value="s">
        <label for="s">Small</label>

        <input type="radio" id="m" name="size" value="m" checked>
        <label for="m">Medium</label>

        <input type="radio" id="l" name="size" value="l">
        <label for="l">Large</label>
    </div>
    <div id="board" style="width: 640px; resize: horizontal; overflow: hidden;"></div>
    <br>
    <br>

    <footer style="padding: 16px; background: #f9f9fb;">
        <p>Using "Magic: The Gathering API(api.magicthegathering.io)".</p>
        <p>Thanks for <a href="https://magicthegathering.io/">MTG Developers</a> and <a href="https://mtgjson.com/">MTGJSON</a>.</p>
    </footer>

    <script>
        $('input[name="size"]').on('change', resizeImage);

        function resizeImage() {
            let img = $('#board img');

            let val = $('input:radio[name="size"]:checked').val();
            switch (val) {
                case 's':
                    img.prop('width', '106');
                    img.prop('height', '148');
                    break;
                case 'm':
                    img.prop('width', '159');
                    img.prop('height', '222');
                    break;
                case 'l':
                    img.prop('width', '212');
                    img.prop('height', '296');
                    break;
            }
        }

        function read() {
            let text = $('#input').val().trim();
            text = text.replace(/\r\n|\r/g, '\n');

            let counts = [];
            let promises = [];

            let sideboard = -1;
            let empty_row = [];
            text.split('\n').forEach(d => {
                if (d === '') {
                    empty_row.push(counts.length);
                }
                if (d === 'Sideboard') {
                    sideboard = counts.length;
                }

                let s = d.trim().split(' ');
                if (s.length >= 3) {
                    let count = Number(s[0]);
                    let set = s[s.length - 2].replace(/[()]/g, '');
                    let number = s[s.length - 1];

                    counts.push(count);
                    promises.push(send(set, number));
                }
            });

            Promise.all(promises).then((data) => {
                data = data.filter(d => d.length !== 0);
                console.log(data);

                // fix api.magicthegathering.io
                data.forEach((d, i) => {
                    d.forEach(d => {
                        d.color = d.color || [];
                        d.colorIdentity = d.colorIdentity || [];
                        d.manaCost = d.manaCost || '';
                    });

                    if (d.length > 1) {
                        if (d[0].imageUrl === d[1].imageUrl) {
                            let url = new URL(d[1].imageUrl);
                            let searchParams = url.searchParams;

                            let id = searchParams.get('multiverseid');
                            searchParams.set('multiverseid', Number(id) + 1);
                            url.search = searchParams.toString();

                            d[1].imageUrl = url.href;
                        }
                    }
                });

                // symbol
                {
                    let symbols = {
                        C: 0,
                        W: 0,
                        U: 0,
                        B: 0,
                        R: 0,
                        G: 0,
                        P: 0,
                        S: 0,
                    };
                    let keys = Object.keys(symbols);
                    data.forEach((d, i) => {
                        let count = counts[i];

                        keys.forEach(key => {
                            if (!d[0].types.includes('Land')) {
                                symbols[key] += (d[0].manaCost.split(key).length - 1) * count;
                            }

                            if (d.length > 1) {
                                if (d[0].layout !== 'transform') {
                                    if (!d[1].types.includes('Land')) {
                                        symbols[key] += (d[1].manaCost.split(key).length - 1) * count;
                                    }
                                }
                            }
                        });
                    });
                    if (symbols.C + symbols.W + symbols.U + symbols.B + symbols.R + symbols.G === 0) {
                        symbols.C = 1;
                    }
                    $('#symbol').html('<canvas></canvas>');
                    let canvas = $('#symbol canvas')[0];
                    canvas.width = 80;
                    canvas.height = 80;

                    new Chart(canvas, {
                        type: 'pie',
                        data: {
                            labels: ['C', 'W', 'U', 'B', 'R', 'G'],
                            datasets: [
                                {
                                    data: [symbols.C, symbols.W, symbols.U, symbols.B, symbols.R, symbols.G],
                                    backgroundColor: ['#E0E0E0', '#FFFDDB', '#C8E0F7', '#D0C7C0', '#E5B08F', '#B7D9B5'],
                                    borderColor: ['#000000', '#000000', '#000000', '#000000', '#000000', '#000000'],
                                },
                            ],
                        },
                        options: {
                            responsive: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Mana Symbol'
                                },
                                legend: false,
                                tooltip: false,
                            },
                        },
                    });
                }

                // cmc
                {
                    let colors = {};
                    ['Colorless', 'White', 'Blue', 'Black', 'Red', 'Green', 'Multicolored'].forEach(d => {
                        colors[d] = {
                            cmc_l: 0,
                            cmc_0: 0,
                            cmc_1: 0,
                            cmc_2: 0,
                            cmc_3: 0,
                            cmc_4: 0,
                            cmc_5: 0,
                            cmc_6: 0,
                            cmc_7: 0,
                            cmc_x: 0,
                        };
                    });
                    let getColorKey = (colorIdentity) => {
                        switch (colorIdentity.length) {
                            case 0:
                                return 'Colorless';
                            case 1:
                                switch (colorIdentity[0]) {
                                    case 'W':
                                        return 'White';
                                    case 'U':
                                        return 'Blue';
                                    case 'B':
                                        return 'Black';
                                    case 'R':
                                        return 'Red';
                                    case 'G':
                                        return 'Green';
                                }
                                break;
                            default:
                                return 'Multicolored';
                        }
                    };
                    let addColorsCount = (d, count) => {
                        let color_key = getColorKey(d.colorIdentity);

                        if (d.types.includes('Land')) {
                            colors[color_key].cmc_l += count;
                        } else if (d.manaCost.includes('{X}')) {
                            colors[color_key].cmc_x += count;
                        } else {
                            switch (d.cmc) {
                                case 0:
                                    colors[color_key].cmc_0 += count;
                                    break;
                                case 1:
                                    colors[color_key].cmc_1 += count;
                                    break;
                                case 2:
                                    colors[color_key].cmc_2 += count;
                                    break;
                                case 3:
                                    colors[color_key].cmc_3 += count;
                                    break;
                                case 4:
                                    colors[color_key].cmc_4 += count;
                                    break;
                                case 5:
                                    colors[color_key].cmc_5 += count;
                                    break;
                                case 6:
                                    colors[color_key].cmc_6 += count;
                                    break;
                                default:
                                    colors[color_key].cmc_7 += count;
                                    break;
                            }
                        }
                    };
                    data.forEach((d, i) => {
                        let count = counts[i];

                        if (sideboard === -1 || count <= sideboard) {
                            addColorsCount(d[0], count);
                            if (d.length > 1) {
                                if (d[0].layout !== 'transform') {
                                    addColorsCount(d[1], count);
                                }
                            }
                        }
                    });
                    $('#cmc').html('<canvas></canvas>');
                    let canvas = $('#cmc canvas')[0];
                    canvas.width = 640;
                    canvas.height = 240;

                    let getCmcArray = (d) => [d.cmc_l, d.cmc_0, d.cmc_1, d.cmc_2, d.cmc_3, d.cmc_4, d.cmc_5, d.cmc_6, d.cmc_7, d.cmc_x];
                    new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: ['Land', '0', '1', '2', '3', '4', '5', '6', '7+', 'X'],
                            datasets: [
                                {
                                    label: 'Colorless',
                                    data: getCmcArray(colors['Colorless']),
                                    backgroundColor: '#E0E0E0',
                                },
                                {
                                    label: 'White',
                                    data: getCmcArray(colors['White']),
                                    backgroundColor: '#FFFDDB',
                                },
                                {
                                    label: 'Blue',
                                    data: getCmcArray(colors['Blue']),
                                    backgroundColor: '#C8E0F7',
                                },
                                {
                                    label: 'Black',
                                    data: getCmcArray(colors['Black']),
                                    backgroundColor: '#D0C7C0',
                                },
                                {
                                    label: 'Red',
                                    data: getCmcArray(colors['Red']),
                                    backgroundColor: '#E5B08F',
                                },
                                {
                                    label: 'Green',
                                    data: getCmcArray(colors['Green']),
                                    backgroundColor: '#B7D9B5',
                                },
                                {
                                    label: 'Multicolored',
                                    data: getCmcArray(colors['Multicolored']),
                                    backgroundColor: '#E5D97C',
                                },
                            ],
                        },
                        options: {
                            responsive: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'CMC',
                                },
                                legend: {
                                    position: 'right',
                                },
                                tooltip: {
                                    bodyAlign: 'right',
                                    footerAlign: 'right',
                                    callbacks: {
                                        footer: (tooltipItem) => {
                                            let sum = tooltipItem.reduce((p, v) => p + v.parsed.y, 0);
                                            return 'Sum: ' + sum;
                                        },
                                    },
                                },
                            },
                            interaction: {
                                intersect: false,
                                mode: 'index',
                            },
                            scales: {
                                x: {
                                    stacked: true,
                                },
                                y: {
                                    stacked: true,
                                },
                            },
                        },
                    });
                }

                // type
                {
                    let types = {};
                    ['Land', 'Planeswalker', 'Creature', 'Artifact', 'Enchantment', 'Instant', 'Sorcery'].forEach(d => {
                        types[d] = {
                            front: 0,
                            back: 0,
                        };
                    });
                    let multitype_front = 0;
                    let multitype_back = 0;

                    let keys = Object.keys(types);
                    data.forEach((d, i) => {
                        let count = counts[i];

                        keys.forEach(key => {
                            if (d[0].types.includes(key)) {
                                types[key].front += count;
                            }

                            if (d.length > 1) {
                                if (d[1].types.includes(key)) {
                                    if (!d[0].types.includes('Land') || !d[1].types.includes('Land')) {
                                        types[key].back += count;
                                    }
                                }
                            }
                        });
                        if (d[0].types.length > 1) {
                            multitype_front += count;
                        }
                        if (d.length > 1) {
                            if (d[1].types.length > 1) {
                                multitype_back += count;
                            }
                        }
                    });
                    let html = '';
                    html += '<table style="border-collapse: collapse">';
                    html += '<tr>';
                    html += '<th>Front</th>';
                    html += '<th>Back</th>';
                    html += '<th>Sum</th>';
                    html += '<th>Card Type</th>';
                    html += '</tr>';
                    keys.forEach(key => {
                        html += '<tr>';
                        html += '<td style="text-align: right;">' + types[key].front + '</td>';
                        html += '<td style="text-align: right;">' + types[key].back + '</td>';
                        html += '<td style="text-align: right;">' + (types[key].front + types[key].back) + '</td>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';

                        switch (key) {
                            case 'Land':
                                html += '<tr style="border-bottom: 1px solid #808080;">';
                                html += '</tr>';
                                break;
                            case 'Enchantment':
                                let frontP = types['Planeswalker'].front + types['Creature'].front + types['Artifact'].front + types['Enchantment'].front;
                                let backP = types['Planeswalker'].back + types['Creature'].back + types['Artifact'].back + types['Enchantment'].back;
                                html += '<tr style="border-bottom: 3px double #BCBCBC;">';
                                html += '</tr>';

                                html += '<tr>';
                                html += '<td style="text-align: right;">' + frontP + '</td>';
                                html += '<td style="text-align: right;">' + backP + '</td>';
                                html += '<td style="text-align: right;">' + (frontP + backP) + '</td>';
                                html += '<td>(Non-land Permanent)</td>';
                                html += '</tr>';

                                html += '<tr style="border-bottom: 1px solid #808080;">';
                                html += '</tr>';
                                break;
                            case 'Sorcery':
                                let frontN = types['Instant'].front + types['Sorcery'].front;
                                let backN = types['Instant'].back + types['Sorcery'].back;
                                html += '<tr style="border-bottom: 3px double #BCBCBC;">';
                                html += '</tr>';

                                html += '<tr>';
                                html += '<td style="text-align: right;">' + frontN + '</td>';
                                html += '<td style="text-align: right;">' + backN + '</td>';
                                html += '<td style="text-align: right;">' + (frontN + backN) + '</td>';
                                html += '<td>(Non-permanent)</td>';
                                html += '</tr>';
                                break;
                        }
                    });
                    html += '</table>';
                    $('#type').html(html);
                }

                // rarity
                {
                    let raritys = {
                        Mythic: 0,
                        Rare: 0,
                        Uncommon: 0,
                        Common: 0,
                    };
                    let keys = Object.keys(raritys);
                    data.forEach((d, i) => {
                        let count = counts[i];

                        raritys[d[0].rarity] += count;
                    });
                    let html = '';
                    html += '<table>';
                    html += '<tr>';
                    html += '<th></th>';
                    html += '<th>Rarity</th>';
                    html += '</tr>';
                    keys.forEach(key => {
                        html += '<tr>';
                        html += '<td style="text-align: right;">' + raritys[key] + '</td>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    });
                    html += '</table>';
                    $('#rarity').html(html);
                }

                // image
                {
                    let html = '';
                    data.forEach((d, i) => {
                        let count = counts[i];

                        if (i !== 0 && empty_row.includes(i)) {
                            html += '<hr style="height: 2px; background: #000000;">';
                        }

                        html += '<div style="display: inline-block; position: relative;">';
                        html += '<img style="position: absolute; z-index: -1; margin: 0; background: #E7E9EB;" alt="" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">';

                        html += '<div class="front">';
                        html += '<p style="position: absolute; z-index: -1; margin: 4px; width: calc(100% - 8px); word-wrap: break-word;">' + d[0].name + '</p>';
                        html += '<img alt="" src="' + d[0].imageUrl + '" onerror="this.style.visibility = \'hidden\'">';
                        html += '</div>';
                        if (d.length > 1) {
                            html += '<div class="back" style="display: none;">';
                            html += '<p style="position: absolute; z-index: -1; margin: 4px; width: calc(100% - 8px); word-wrap: break-word;">' + d[1].name + '</p>';
                            html += '<img alt="" src="' + d[1].imageUrl + '" onerror="this.style.visibility = \'hidden\'">';
                            html += '</div>';

                            html += '<span class="flip material-symbols-outlined" style="position: absolute; bottom: 0; left: calc(50% - 12px); border-radius: 50%; background: white; cursor: pointer;">sync</span>';
                        }
                        html += '<p style="position: absolute; bottom: 8px; margin: 8px; border-radius: 4px; width: 20%; font-weight: bold; text-align: center; background: white;">' + count + '</p>';
                        html += '</div>';
                    });
                    $('#board')
                        .html(html)
                        .on('click', '.flip', e => {
                            let target = $(e.target);
                            let back = target.prev();
                            let front = back.prev();

                            back.toggle();
                            front.toggle();
                        });

                    resizeImage();
                }

                // format
                {
                    let formats = {
                        paper: ['Standard', 'Pioneer', 'Modern', 'Legacy', 'Vintage', 'Pauper'],
                        arena: ['Alchemy', 'Historic'],
                    };
                    data.forEach((d, i) => {
                        let legalities = d[0].legalities.map(d => d.format);
                        formats.paper = formats.paper.filter(d => legalities.includes(d));
                        formats.arena = formats.arena.filter(d => legalities.includes(d));
                    });
                    let html = '';
                    html += '<table>';
                    html += '<tr>';
                    html += '<th>Format</th>';
                    html += '</tr>';
                    html += '<tr>';
                    html += formats.paper.map(d => '<td>' + d + '</td>').join('');
                    html += '</tr>';
                    html += '<tr>';
                    html += formats.arena.map(d => '<td>' + d + '</td>').join('');
                    html += '</tr>';
                    html += '</table>';
                    $('#format').html(html);
                }
            });
        }

        function send(set, number) {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', 'https://api.magicthegathering.io/v1/cards?set=' + set + '&number=' + number);
                request.onload = () => {
                    let data = JSON.parse(request.response);
                    resolve(data.cards);
                };
                request.onerror = () => {
                    reject();
                }
                request.send();
            });
        }
    </script>
</body>

</html>
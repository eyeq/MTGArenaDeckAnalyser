<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>MTG Arena Deck Analyser</title>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>

    <link rel="stylesheet" href="https://fonts.sandbox.google.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <style>
        th {
            text-align: left;
        }

        #board {
            max-width: 1120px;
        }

        #board[style*="width"] {
            max-width: unset;
        }
    </style>
</head>

<body>
    <div id="progress" style="position: fixed; z-index: 100; left: 0; top: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.2); display: none;">
        <progress style="position: fixed; left: calc(50% - 160px); top: 50%; width: 320px; height: 40px;"></progress>
    </div>
    <header>
        <h1>MTG Arena Deck Analyser</h1>
    </header>

    <div style="display: inline-block; vertical-align: top;">
        <h2 style="margin-bottom: 0;">Input</h2>
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <textarea id="input" style="width: 400px; height: 240px;" placeholder="Export a Deck from MTG Arena" onchange="read();"></textarea>
        </div>
    </div>

    <div style="display: inline-block; vertical-align: top;">
        <h2 style="margin-bottom: 0;">Share this deck</h2>
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <textarea id="output" style="width: 400px; height: 200px; background-color: #F0F0F0;" readonly onclick="this.select();"></textarea>
            <div id="link"></div>
        </div>
    </div>

    <h2 style="margin-bottom: 0;">Output</h2>
    <div style="display: inline-block; vertical-align: top;">
        <div style="display: inline-block; vertical-align: top; margin: 8px; width: 160px;;">
            <h3>Main Set</h3>
            <div id="set"></div>
        </div>
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <h3>Format</h3>
            <div id="format"></div>
        </div>
    </div>
    <br>

    <div style="display: inline-block; vertical-align: top; width: 100%;; max-width: 1120px;">
        <div style="display: inline-block; vertical-align: top; margin: 8px; width: 160px;">
            <h3>Color</h3>
            <div id="color"></div>
            <br>
            <table>
                <tr>
                    <th>Mana Symbol</th>
                </tr>
                <tr>
                    <td>
                        <div id="symbol"></div>
                    </td>
                </tr>
            </table>
        </div>
        <div style="display: inline-block; vertical-align: top; margin: 8px; width: calc(100% - 200px);">
            <h3>Archetype</h3>
            <div id="decktype"></div>
            <br>
            <table style="width: 100%;">
                <tr>
                    <th style="width: 20%;">Keycard</th>
                    <th style="width: 20%;">Supertype</th>
                    <th style="width: 20%;">Subtype</th>
                    <th style="width: 20%;">Keyword</th>
                    <th style="width: 20%;">Type</th>
                </tr>
                <tr>
                    <td style="vertical-align: top;">
                        <div id="keycard"></div>
                    </td>
                    <td style="vertical-align: top;">
                        <div id="supertype"></div>
                    </td>
                    <td style="vertical-align: top;">
                        <div id="subtype"></div>
                    </td>
                    <td style="vertical-align: top;">
                        <div id="keyword"></div>
                    </td>
                    <td style="vertical-align: top;">
                        <div id="archetype"></div>
                    </td>
                </tr>
            </table>
        </div>
    </div>
    <br>

    <h3 id="mainboard" style="margin-bottom: 0;">Main</h3>
    <div style="display: inline-block; vertical-align: top; width: 480px;">
        <div style="display: inline-block; vertical-align: top; margin: 8px; width: 160px;">
            <h4>Rarity</h4>
            <div id="rarity_main"></div>
            <h4>Price</h4>
            <div id="price_main"></div>
        </div>
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <h4>Card Type</h4>
            <div id="type_main"></div>
        </div>
    </div>

    <div style="display: inline-block; vertical-align: top; width: 662px;">
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <h4>Mana Curve</h4>
            <div id="cmc_main"></div>
        </div>
    </div>
    <br>

    <h3 id="sideboard" style="margin-bottom: 0;">Sideboard</h3>
    <div style="display: inline-block; vertical-align: top; width: 480px;">
        <div style="display: inline-block; vertical-align: top; margin: 8px; width: 160px;">
            <h4>Rarity</h4>
            <div id="rarity_side"></div>
            <h4>Price</h4>
            <div id="price_side"></div>
        </div>
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <h4>Card Type</h4>
            <div id="type_side"></div>
        </div>
    </div>

    <div style="display: inline-block; vertical-align: top; width: 662px;">
        <div style="display: inline-block; vertical-align: top; margin: 8px;">
            <h4>Mana Curve</h4>
            <div id="cmc_side"></div>
        </div>
    </div>

    <h3>Image</h3>
    <div style="display: inline-block; vertical-align: top; margin: 8px;">
        <input type="radio" id="t" name="size" value="t">
        <label for="t">Tiny</label>

        <input type="radio" id="s" name="size" value="s" checked>
        <label for="s">Small</label>

        <input type="radio" id="m" name="size" value="m">
        <label for="m">Medium</label>

        <input type="radio" id="l" name="size" value="l">
        <label for="l">Large</label>

        <input type="radio" id="h" name="size" value="h">
        <label for="h">Huge</label>
    </div>
    <br>

    <div style="display: inline-block; vertical-align: top; margin: 8px;">
        <div id="board" style="resize: horizontal; overflow: hidden;"></div>
    </div>
    <br>
    <br>

    <footer style="padding: 16px; background: #f9f9fb;">
        <p>Using Scryfall REST API(api.scryfall.com)".</p>
        <p>Thanks for <a href="https://scryfall.com/">Scryfall Magic: The Gathering Search</a>.</p>
    </footer>

    <script>
        let super_types = [
            // 'Basic',
            // 'Legendary',
            'Legendary Sorcery',
            // 'Ongoing'.
            'Snow',
            'World',
            // 'Elite',
            // 'Host',
        ];
        let land_types = [
            // 'Plains',
            // 'Island',
            // 'Swamp',
            // 'Mountain',
            // 'Forest',
            'Desert',
            'Gate',
            // 'Lair',
            // 'Locus',
            // 'Urzaâ€™s',
            // 'Mine',
            // 'Power-Plant',
            // 'Tower',
        ];
        let creature_types = [];
        let permanent_types = [
            'Blood',
            'Clue',
            // 'Contraption',
            'Food',
            // 'Gold',
            'Treasure',
        ];
        let artifact_types = [
            'Equipment',
            'Fortification',
            'Vehicle',
        ];
        let enchantment_types = [
            'Aura',
            'Cartouche',
            // 'Class',
            'Curse',
            'Rune',
            'Saga',
            // 'Shard',
            'Shrine',
        ];
        let spell_types = [
            'Adventure',
            'Arcane',
            // 'Lesson'.
            // 'Trap',
        ];
        let keyword_abilitys = {
            'Deathtouch': { show: true, type: 'block' },
            'Defender': { show: true, type: 'block' },
            'Double Strike': { show: true, type: 'attack' },
            'Enchant': { show: false, type: 'other' },
            'Equip': { show: false, type: 'other' },
            'First Strike': { show: true, type: 'attack' },
            'Flash': { show: false, type: 'prevent' },
            'Flying': { show: true, type: 'attack' },
            'Haste': { show: true, type: 'attack' },
            'Hexproof': { show: true, type: 'prevent' },
            'Indestructible': { show: true, type: 'prevent' },
            'Intimidate': { show: true, type: 'attack' },
            'Landwalk': { show: true, type: 'attack' },
            'Lifelink': { show: true, type: 'block' },
            'Protection': { show: true, type: 'prevent' },
            'Reach': { show: true, type: 'block' },
            'Shroud': { show: true, type: 'prevent' },
            'Trample': { show: true, type: 'attack' },
            'Vigilance': { show: true, type: 'block' },
            'Ward': { show: true, type: 'prevent' },
            'Banding': { show: true, type: 'other' },
            'Rampage': { show: true, type: 'attack' },
            'Cumulative Upkeep': { show: true, type: 'other' },
            'Flanking': { show: true, type: 'attack' },
            'Phasing': { show: true, type: 'prevent' },
            'Buyback': { show: true, type: 'cast' },
            'Shadow': { show: true, type: 'attack' },
            'Cycling': { show: true, type: 'from_hand' },
            'Echo': { show: true, type: 'other' },
            'Horsemanship': { show: true, type: 'attack' },
            'Fading': { show: true, type: 'other' },
            'Kicker': { show: true, type: 'cast' },
            'Flashback': { show: true, type: 'from_graveyard' },
            'Madness': { show: true, type: 'from_hand' },
            'Fear': { show: true, type: 'attack' },
            'Morph': { show: true, type: 'cast' },
            'Amplify': { show: true, type: 'other' },
            'Provoke': { show: true, type: 'attack' },
            'Storm': { show: true, type: 'cast' },
            'Affinity': { show: true, type: 'cast' },
            'Entwine': { show: true, type: 'cast' },
            'Modular': { show: true, type: 'prevent' },
            'Sunburst': { show: true, type: 'other' },
            'Bushido': { show: true, type: 'block' },
            'Soulshift': { show: true, type: 'prevent' },
            'Splice': { show: true, type: 'cast' },
            'Offering': { show: true, type: 'cast' },
            'Ninjutsu': { show: true, type: 'attack' },
            'Epic': { show: true, type: 'other' },
            'Convoke': { show: true, type: 'cast' },
            'Dredge': { show: true, type: 'from_graveyard' },
            'Transmute': { show: true, type: 'cast' },
            'Bloodthirst': { show: true, type: 'attack' },
            'Haunt': { show: true, type: 'prevent' },
            'Replicate': { show: true, type: 'cast' },
            'Forecast': { show: true, type: 'cast' },
            'Graft': { show: true, type: 'other' },
            'Recover': { show: true, type: 'prevent' },
            'Ripple': { show: true, type: 'other' },
            'Split Second': { show: false, type: 'prevent' },
            'Suspend': { show: true, type: 'cast' },
            'Vanishing': { show: true, type: 'other' },
            'Absorb': { show: true, type: 'block' },
            'Aura Swap': { show: true, type: 'other' },
            'Delve': { show: true, type: 'cast' },
            'Fortify': { show: false, type: 'other' },
            'Frenzy': { show: true, type: 'attack' },
            'Gravestorm': { show: false, type: 'cast' },
            'Poisonous': { show: true, type: 'attack' },
            'Transfigure': { show: true, type: 'other' },
            'Champion': { show: true, type: 'prevent' },
            'Changeling': { show: false, type: 'other' },
            'Evoke': { show: true, type: 'cast' },
            'Hideaway': { show: true, type: 'other' },
            'Prowl': { show: true, type: 'attack' },
            'Reinforce': { show: true, type: 'from_hand' },
            'Conspire': { show: true, type: 'cast' },
            'Persist': { show: true, type: 'prevent' },
            'Wither': { show: true, type: 'block' },
            'Retrace': { show: true, type: 'from_graveyard' },
            'Devour': { show: true, type: 'other' },
            'Exalted': { show: true, type: 'attack' },
            'Unearth': { show: true, type: 'from_graveyard' },
            'Cascade': { show: true, type: 'cast' },
            'Annihilator': { show: true, type: 'attack' },
            'Level Up': { show: false, type: 'other' },
            'Rebound': { show: true, type: 'other' },
            'Totem Armor': { show: false, type: 'prevent' },
            'Infect': { show: true, type: 'attack' },
            'Battle Cry': { show: true, type: 'attack' },
            'Living Weapon': { show: false, type: 'prevent' },
            'Undying': { show: true, type: 'prevent' },
            'Miracle': { show: true, type: 'cast' },
            'Soulbond': { show: true, type: 'other' },
            'Overload': { show: true, type: 'cast' },
            'Scavenge': { show: true, type: 'from_graveyard' },
            'Unleash': { show: true, type: 'attack' },
            'Cipher': { show: true, type: 'attack' },
            'Evolve': { show: true, type: 'attack' },
            'Extort': { show: true, type: 'other' },
            'Fuse': { show: true, type: 'cast' },
            'Bestow': { show: true, type: 'cast' },
            'Tribute': { show: true, type: 'attack' },
            'Dethrone': { show: true, type: 'attack' },
            'Hidden Agenda': { show: false, type: 'other' },
            'Outlast': { show: true, type: 'other' },
            'Prowess': { show: true, type: 'attack' },
            'Dash': { show: true, type: 'cast' },
            'Exploit': { show: true, type: 'other' },
            'Menace': { show: true, type: 'attack' },
            'Renown': { show: true, type: 'other' },
            'Awaken': { show: true, type: 'cast' },
            'Devoid': { show: false, type: 'other' },
            'Ingest': { show: true, type: 'attack' },
            'Myriad': { show: true, type: 'attack' },
            'Surge': { show: true, type: 'cast' },
            'Skulk': { show: true, type: 'attack' },
            'Emerge': { show: true, type: 'cast' },
            'Escalate': { show: true, type: 'cast' },
            'Melee': { show: true, type: 'attack' },
            'Crew': { show: false, type: 'other' },
            'Fabricate': { show: true, type: 'other' },
            'Partner': { show: false, type: 'other' },
            'Undaunted': { show: true, type: 'cast' },
            'Improvise': { show: true, type: 'cast' },
            'Aftermath': { show: true, type: 'from_graveyard' },
            'Embalm': { show: true, type: 'from_graveyard' },
            'Eternalize': { show: true, type: 'from_graveyard' },
            'Afflict': { show: true, type: 'attack' },
            'Ascend': { show: true, type: 'other' },
            'Assist': { show: false, type: 'cast' },
            'Jump-Start': { show: true, type: 'from_graveyard' },
            'Mentor': { show: true, type: 'attack' },
            'Afterlife': { show: true, type: 'prevent' },
            'Riot': { show: true, type: 'attack' },
            'Spectacle': { show: true, type: 'attack' },
            'Escape': { show: true, type: 'from_graveyard' },
            'Companion': { show: false, type: 'other' },
            'Mutate': { show: true, type: 'other' },
            'Encore': { show: true, type: 'from_graveyard' },
            'Boast': { show: true, type: 'attack' },
            'Foretell': { show: true, type: 'cast' },
            'Demonstrate': { show: true, type: 'cast' },
            'Daybound': { show: true, type: 'other' },
            // 'Nightbound'
            'Disturb': { show: true, type: 'from_graveyard' },
            'Decayed': { show: true, type: 'attack' },
            'Cleave': { show: true, type: 'cast' },
            'Training': { show: true, type: 'attack' },
            'Compleated': { show: false, type: 'cast' },
            'Reconfigure': { show: false, type: 'other' },
            'Blitz': { show: true, type: 'cast' },
            'Casualty': { show: true, type: 'cast' },
        };
        let ability_words = [
            'Adamant',
            'Addendum',
            'Alliance',
            'Battalion',
            'Bloodrush',
            'Channel',
            'Chroma',
            'Cohort',
            'Constellation',
            'Converge',
            'Council\'s dilemma',
            'Coven',
            'Delirium',
            'Domain',
            // 'Eminence',
            'Enrage',
            'Fateful hour',
            'Ferocious',
            'Formidable',
            'Grandeur',
            'Hellbent',
            'Heroic',
            'Imprint',
            'Inspired',
            'Join forces',
            'Kinship',
            'Landfall',
            'Lieutenant',
            'Magecraft',
            'Metalcraft',
            'Morbid',
            'Pack tactics',
            'Parley',
            'Radiance',
            'Raid',
            'Rally',
            'Revolt',
            'Spell mastery',
            'Strive',
            'Sweep',
            'Tempting offer',
            'Threshold',
            'Underdog',
            'Undergrowth',
            'Will of the council',

            // 'Gotcha!',
            // 'Hero's Reward',
            // 'Spiritcraft',
        ];
        let keyword_actions = [
            // 'Activate',
            // 'Attach',
            // 'Unattach',
            // 'Cast',
            // 'Counter',
            // 'Create',
            // 'Destroy',
            // 'Discard',
            // 'Double',
            // 'Exchange',
            // 'Exile',
            'Fight',
            // 'Mill',
            // 'Play',
            'Regenerate',
            // 'Reveal',
            'Sacrifice',
            'Scry',
            // 'Search',
            // 'Shuffle',
            // 'Tap',
            // 'Untap',
            'Fateseal',
            'Clash',
            // 'Planeswalk',
            // 'Set in Motion',
            // 'Abandon',
            'Proliferate',
            'Transform',
            'Detain',
            'Populate',
            'Monstrosity',
            'Vote',
            'Bolster',
            'Manifest',
            'Investigate',
            'Meld',
            'Goad',
            'Exert',
            'Explore',
            // 'Assemble',
            'Surveil',
            'Adapt',
            'Amass',
            'Learn',
            'Venture into the Dungeon',
            'Connive',

            // 'Ante',
            // 'Ban',
            // 'Bury',
        ];

        (() => {
            let url = new URL(location.href);
            let searchParams = url.searchParams;

            let input = searchParams.get('input');
            if (input) {
                let val = '';
                input.split('_').forEach((d, i) => {
                    val += d;
                    if (i % 3 === 2) {
                        val += '\n';
                    } else {
                        val += ' ';
                    }
                });
                $('#input').val(val);
            }

            $('input[name="size"]').on('change', resizeImage);

            $('#keycard').on('mouseenter', '.key', e => {
                let target = $(e.target);
                target.next().show();
            }).on('mouseleave', '.key', e => {
                let target = $(e.target);
                target.next().hide();
            });

            $('#board').on('click', '.flip', e => {
                let target = $(e.target);
                let back = target.prev();
                let front = back.prev();

                back.toggle();
                front.toggle();
            });

            sendCatalogCreatureTypes().then(data => {
                console.log(data);
                creature_types = data.data;

                read();
            });
        })();

        function resizeImage() {
            let img = $('#board img');
            let p = $('#board span');

            let val = $('input:radio[name="size"]:checked').val();
            switch (val) {
                case 't':
                    img.prop('width', '122');
                    img.prop('height', '170');
                    p.css('font-size', '16px');
                    break;
                case 's':
                    img.prop('width', '183');
                    img.prop('height', '255');
                    p.css('font-size', '24px');
                    break;
                case 'm':
                    img.prop('width', '244');
                    img.prop('height', '340');
                    p.css('font-size', '32px');
                    break;
                case 'l':
                    img.prop('width', '366');
                    img.prop('height', '510');
                    p.css('font-size', '48px');
                    break;
                case 'h':
                    img.prop('width', '488');
                    img.prop('height', '680');
                    p.css('font-size', '72px');
                    break;
            }
        }

        async function read() {
            let text = $('#input').val().trim();
            text = text.replace(/\r\n|\r/g, '\n');

            let inputs = [];

            let commander = false;
            let sideboard = 10000;
            let empty_row = [];
            text.split('\n').forEach(d => {
                d = d.trim();
                if (d === 'Commander') {
                    commander = true;
                }

                let index0 = d.indexOf(' ');
                if (index0 === -1) {
                    if (inputs.length !== 0) {
                        sideboard = inputs.length;
                        empty_row.push(inputs.length);
                    }
                } else {
                    let index1 = d.indexOf(' (');
                    let s = d.split(' ');

                    let count = Number(s[0]);

                    let name = '';
                    if (index1 === -1) {
                        name = d.substr(index0 + 1);
                    } else {
                        name = d.substr(index0 + 1, index1 - 2);
                    }

                    let set = '';
                    let number = '';
                    if (s.length >= 3) {
                        set = s[s.length - 2].replace(/[()]/g, '');
                        number = s[s.length - 1];
                    }
                    inputs.push({
                        count: count,
                        name: name,
                        set: set,
                        number: number,
                    })
                }
            });

            let data = [];
            $('#progress progress').prop('max', inputs.length)
            $('#progress progress').prop('value', 0);
            $('#progress').show();
            for (let i = 0; i < inputs.length; i++) {
                let d = inputs[i];
                let ret = await send(d.name, d.set, d.number);
                if (ret) {
                    ret.count = d.count;
                    ret.sideboard = !commander && i >= sideboard;
                }
                data.push(ret);

                $('#progress progress').prop('value', i + 1);
            }
            $('#progress').hide();

            // counts
            let counts_main = 0;
            let counts_side = 0;
            {
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (!d.sideboard) {
                        counts_main += d.count;
                    } else {
                        counts_side += d.count;
                    }
                });

                $('#mainboard').html('Main (' + counts_main + ')');
                $('#sideboard').html('Sideboard (' + counts_side + ')');
            }

            // link
            {
                let link = location.pathname + '?input=';
                data.forEach((d, i) => {
                    if (empty_row.includes(i)) {
                        link += '___';
                    }
                    if (!d) {
                        return;
                    }

                    link += d.count + '_' + d.set.toUpperCase() + '_' + d.collector_number + '_';
                });
                $('#link').html('<a href="' + link + '">Copy link address</a>');
            }

            // output
            {
                let val = '';
                if (commander) {
                    val += 'Commander\n';
                } else {
                    val += 'Deck\n';
                }
                let first = true;
                let sideboard = true;
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (sideboard && d.sideboard) {
                        val += '\nSideboard\n';
                        sideboard = false;
                    }
                    val += d.count + ' ' + d.name + ' (' + d.set.toUpperCase() + ') ' + d.collector_number + '\n';
                    if (commander && first) {
                        val += '\nDeck\n';
                    }
                    first = false;
                });
                $('#output').val(val);
            }

            // color / symbol
            let symbols = {
                C: 0,
                W: 0,
                U: 0,
                B: 0,
                R: 0,
                G: 0,
                P: 0,
                S: 0,
            };
            {
                let keys = Object.keys(symbols);
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    keys.forEach(key => {
                        if (d.mana_cost) {
                            symbols[key] += (d.mana_cost.split(key).length - 1) * d.count;
                        }
                    });
                });
                symbols.sum = symbols.W + symbols.U + symbols.B + symbols.G + symbols.R;

                if (symbols.C + symbols.W + symbols.U + symbols.B + symbols.R + symbols.G === 0) {
                    symbols.C = 1;
                }

                // symbol
                $('#symbol').html('<canvas></canvas>');
                let canvas = $('#symbol canvas')[0];
                canvas.width = 160;
                canvas.height = 160;

                new Chart(canvas, {
                    type: 'pie',
                    data: {
                        labels: ['C', 'W', 'U', 'B', 'R', 'G'],
                        datasets: [
                            {
                                data: [symbols.C, symbols.W, symbols.U, symbols.B, symbols.R, symbols.G],
                                backgroundColor: ['#E0E0E0', '#FFFDDB', '#C8E0F7', '#D0C7C0', '#E5B08F', '#B7D9B5'],
                                borderColor: ['#000000', '#000000', '#000000', '#000000', '#000000', '#000000'],
                            },
                        ],
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: false,
                            tooltip: false,
                        },
                    },
                });

                // color
                let colors = [];
                if (symbols.W / symbols.sum >= 0.12) {
                    colors.push('White');
                }
                if (symbols.U / symbols.sum >= 0.12) {
                    colors.push('Blue');
                }
                if (symbols.B / symbols.sum >= 0.12) {
                    colors.push('Black');
                }
                if (symbols.R / symbols.sum >= 0.12) {
                    colors.push('Red');
                }
                if (symbols.G / symbols.sum >= 0.12) {
                    colors.push('Green');
                }
                switch (colors.length) {
                    case 0:
                        $('#color').html('Colorless');
                        break;
                    case 1:
                        $('#color').html('Mono ' + colors[0]);
                        break;
                    case 2:
                        if (colors.includes('White') && colors.includes('Blue')
                            || colors.includes('Blue') && colors.includes('Black')
                            || colors.includes('Black') && colors.includes('Red')
                            || colors.includes('Red') && colors.includes('Green')
                            || colors.includes('Green') && colors.includes('White')) {
                            $('#color').html(colors.join(' ') + '<br><span style="position: absolute;">(Allied)</span>');
                        } else {
                            $('#color').html(colors.join(' ') + '<br><span style="position: absolute;">(Enemy)</span>');
                        }
                        break;
                    case 3:
                        if (colors.includes('Green') && colors.includes('White') && colors.includes('Blue')
                            || colors.includes('White') && colors.includes('Blue') && colors.includes('Black')
                            || colors.includes('Blue') && colors.includes('Black') && colors.includes('Red')
                            || colors.includes('Black') && colors.includes('Red') && colors.includes('Green')
                            || colors.includes('Red') && colors.includes('Green') && colors.includes('White')) {
                            $('#color').html(colors.join(' ') + '<br><span style="position: absolute;">(Shard)</span>');
                        } else {
                            $('#color').html(colors.join(' ') + '<br><span style="position: absolute;">(Wedge)</span>');
                        }
                        break;
                    case 4:
                        $('#color').html('4-color');
                        break;
                    case 5:
                        $('#color').html('5-color');
                        break;
                }
            }

            // cmc
            {
                let keys = ['Colorless', 'White', 'Blue', 'Black', 'Red', 'Green', 'Multicolored'];
                let colors_main = {};
                let colors_side = {};
                keys.forEach(d => {
                    colors_main[d] = {
                        cmc_l: 0,
                        cmc_0: 0,
                        cmc_1: 0,
                        cmc_2: 0,
                        cmc_3: 0,
                        cmc_4: 0,
                        cmc_5: 0,
                        cmc_6: 0,
                        cmc_7: 0,
                        cmc_x: 0,
                    };
                    colors_side[d] = {
                        cmc_l: 0,
                        cmc_0: 0,
                        cmc_1: 0,
                        cmc_2: 0,
                        cmc_3: 0,
                        cmc_4: 0,
                        cmc_5: 0,
                        cmc_6: 0,
                        cmc_7: 0,
                        cmc_x: 0,
                    };
                });
                let getColorKey = (colors) => {
                    if (!colors) {
                        return 'Colorless';
                    }
                    switch (colors.length) {
                        case 0:
                            return 'Colorless';
                        case 1:
                            switch (colors[0]) {
                                case 'W':
                                    return 'White';
                                case 'U':
                                    return 'Blue';
                                case 'B':
                                    return 'Black';
                                case 'R':
                                    return 'Red';
                                case 'G':
                                    return 'Green';
                            }
                            break;
                        default:
                            return 'Multicolored';
                    }
                };
                let addColorsCount = (colors, d, count) => {
                    let color_key = getColorKey(d.colors);

                    if (d.type_line.includes('Land')) {
                        colors[color_key].cmc_l += count;
                    } else if (d.mana_cost) {
                        if (d.mana_cost.includes('{X}')) {
                            colors[color_key].cmc_x += count;
                        } else {
                            let cmc = 0;
                            let n = d.mana_cost.replace(/[^0-9]/g, '');
                            if (n) {
                                cmc += Number(n);
                                cmc += d.mana_cost.split('{').length - 2;
                            } else {
                                cmc += d.mana_cost.split('{').length - 1;
                            }

                            switch (cmc) {
                                case 0:
                                    colors[color_key].cmc_0 += count;
                                    break;
                                case 1:
                                    colors[color_key].cmc_1 += count;
                                    break;
                                case 2:
                                    colors[color_key].cmc_2 += count;
                                    break;
                                case 3:
                                    colors[color_key].cmc_3 += count;
                                    break;
                                case 4:
                                    colors[color_key].cmc_4 += count;
                                    break;
                                case 5:
                                    colors[color_key].cmc_5 += count;
                                    break;
                                case 6:
                                    colors[color_key].cmc_6 += count;
                                    break;
                                default:
                                    colors[color_key].cmc_7 += count;
                                    break;
                            }
                        }
                    }
                };
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (!d.sideboard) {
                        if (d.card_faces) {
                            addColorsCount(colors_main, d.card_faces[0], d.count);
                            if (d.layout !== 'transform') {
                                addColorsCount(colors_main, d.card_faces[1], d.count);
                            }
                        } else {
                            addColorsCount(colors_main, d, d.count);
                        }
                    } else {
                        if (d.card_faces) {
                            addColorsCount(colors_side, d.card_faces[0], d.count);
                            if (d.layout !== 'transform') {
                                addColorsCount(colors_side, d.card_faces[1], d.count);
                            }
                        } else {
                            addColorsCount(colors_side, d, d.count);
                        }
                    }
                });

                let getCmcArray = (d) => [d.cmc_l, d.cmc_0, d.cmc_1, d.cmc_2, d.cmc_3, d.cmc_4, d.cmc_5, d.cmc_6, d.cmc_7, d.cmc_x];

                $('#cmc_main').html('<canvas></canvas>');
                let canvas = $('#cmc_main canvas')[0];
                canvas.width = 640;
                canvas.height = 240;

                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: ['Land', '0', '1', '2', '3', '4', '5', '6', '7+', 'X'],
                        datasets: [
                            {
                                label: 'Colorless',
                                data: getCmcArray(colors_main['Colorless']),
                                backgroundColor: '#E0E0E0',
                            },
                            {
                                label: 'White',
                                data: getCmcArray(colors_main['White']),
                                backgroundColor: '#FFFDDB',
                            },
                            {
                                label: 'Blue',
                                data: getCmcArray(colors_main['Blue']),
                                backgroundColor: '#C8E0F7',
                            },
                            {
                                label: 'Black',
                                data: getCmcArray(colors_main['Black']),
                                backgroundColor: '#D0C7C0',
                            },
                            {
                                label: 'Red',
                                data: getCmcArray(colors_main['Red']),
                                backgroundColor: '#E5B08F',
                            },
                            {
                                label: 'Green',
                                data: getCmcArray(colors_main['Green']),
                                backgroundColor: '#B7D9B5',
                            },
                            {
                                label: 'Multicolored',
                                data: getCmcArray(colors_main['Multicolored']),
                                backgroundColor: '#E5D97C',
                            },
                        ],
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: {
                                position: 'right',
                            },
                            tooltip: {
                                bodyAlign: 'right',
                                footerAlign: 'right',
                                callbacks: {
                                    footer: (tooltipItem) => {
                                        let sum = tooltipItem.reduce((p, v) => p + v.parsed.y, 0);
                                        return 'Sum: ' + sum;
                                    },
                                },
                            },
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: {
                                stacked: true,
                            },
                            y: {
                                stacked: true,
                            },
                        },
                    },
                });

                $('#cmc_side').html('<canvas></canvas>');
                canvas = $('#cmc_side canvas')[0];
                canvas.width = 640;
                canvas.height = 240;

                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: ['Land', '0', '1', '2', '3', '4', '5', '6', '7+', 'X'],
                        datasets: [
                            {
                                label: 'Colorless',
                                data: getCmcArray(colors_side['Colorless']),
                                backgroundColor: '#E0E0E0',
                            },
                            {
                                label: 'White',
                                data: getCmcArray(colors_side['White']),
                                backgroundColor: '#FFFDDB',
                            },
                            {
                                label: 'Blue',
                                data: getCmcArray(colors_side['Blue']),
                                backgroundColor: '#C8E0F7',
                            },
                            {
                                label: 'Black',
                                data: getCmcArray(colors_side['Black']),
                                backgroundColor: '#D0C7C0',
                            },
                            {
                                label: 'Red',
                                data: getCmcArray(colors_side['Red']),
                                backgroundColor: '#E5B08F',
                            },
                            {
                                label: 'Green',
                                data: getCmcArray(colors_side['Green']),
                                backgroundColor: '#B7D9B5',
                            },
                            {
                                label: 'Multicolored',
                                data: getCmcArray(colors_side['Multicolored']),
                                backgroundColor: '#E5D97C',
                            },
                        ],
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: {
                                position: 'right',
                            },
                            tooltip: {
                                bodyAlign: 'right',
                                footerAlign: 'right',
                                callbacks: {
                                    footer: (tooltipItem) => {
                                        let sum = tooltipItem.reduce((p, v) => p + v.parsed.y, 0);
                                        return 'Sum: ' + sum;
                                    },
                                },
                            },
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: {
                                stacked: true,
                            },
                            y: {
                                stacked: true,
                            },
                        },
                    },
                });
            }

            // type
            {
                let keys = ['Land', 'Planeswalker', 'Creature', 'Artifact', 'Enchantment', 'Instant', 'Sorcery'];
                let types_main = {};
                let types_side = {};
                keys.forEach(d => {
                    types_main[d] = {
                        front: 0,
                        back: 0,
                    };
                    types_side[d] = {
                        front: 0,
                        back: 0,
                    };
                });

                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (!d.sideboard) {
                        keys.forEach(key => {
                            if (d.card_faces && key !== 'Land') {
                                if (d.card_faces[0].type_line.includes(key)) {
                                    types_main[key].front += d.count;
                                }
                                if (d.card_faces[1].type_line.includes(key)) {
                                    types_main[key].front += d.count;
                                }
                            } else {
                                if (d.type_line.includes(key)) {
                                    types_main[key].front += d.count;
                                }
                            }
                        });
                    } else {
                        keys.forEach(key => {
                            if (d.card_faces && key !== 'Land') {
                                if (d.card_faces[0].type_line.includes(key)) {
                                    types_side[key].front += d.count;
                                }
                                if (d.card_faces[1].type_line.includes(key)) {
                                    types_side[key].front += d.count;
                                }
                            } else {
                                if (d.type_line.includes(key)) {
                                    types_side[key].front += d.count;
                                }
                            }
                        });
                    }
                });

                let permanent_spell = types_main['Planeswalker'].front + types_main['Creature'].front + types_main['Artifact'].front + types_main['Enchantment'].front
                    + types_main['Planeswalker'].back + types_main['Creature'].back + types_main['Artifact'].back + types_main['Enchantment'].back;
                let nonpermanent_spell = types_main['Instant'].front + types_main['Sorcery'].front
                    + types_main['Instant'].back + types_main['Sorcery'].back;

                let html = '';
                html += '<table style="border-collapse: collapse">';
                keys.forEach(key => {
                    html += '<tr>';
                    html += '<td style="text-align: right;">' + (types_main[key].front + types_main[key].back) + '</td>';
                    html += '<td>' + key + '</td>';
                    html += '</tr>';

                    switch (key) {
                        case 'Land':
                        case 'Enchantment':
                            html += '<tr style="border-bottom: ridge;">';
                            html += '</tr>';
                            break;
                    }
                });
                html += '<tr style="border-bottom: double;">';
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + permanent_spell + '</td>'
                html += '<td>Permanent Sepll</td>'
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + nonpermanent_spell + '</td>'
                html += '<td>Non-permanent Sepll</td>'
                html += '</tr>';
                html += '</table>';
                $('#type_main').html(html);

                permanent_spell = types_side['Planeswalker'].front + types_side['Creature'].front + types_side['Artifact'].front + types_side['Enchantment'].front
                    + types_side['Planeswalker'].back + types_side['Creature'].back + types_side['Artifact'].back + types_side['Enchantment'].back;
                nonpermanent_spell = types_side['Instant'].front + types_side['Sorcery'].front
                    + types_side['Instant'].back + types_side['Sorcery'].back;

                html = '';
                html += '<table style="border-collapse: collapse">';
                keys.forEach(key => {
                    html += '<tr>';
                    html += '<td style="text-align: right;">' + (types_side[key].front + types_side[key].back) + '</td>';
                    html += '<td>' + key + '</td>';
                    html += '</tr>';

                    switch (key) {
                        case 'Land':
                        case 'Enchantment':
                            html += '<tr style="border-bottom: ridge;">';
                            html += '</tr>';
                            break;
                    }
                });
                html += '<tr style="border-bottom: double;">';
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + permanent_spell + '</td>'
                html += '<td>Permanent Sepll</td>'
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + nonpermanent_spell + '</td>'
                html += '<td>Non-permanent Sepll</td>'
                html += '</tr>';
                html += '</table>';
                $('#type_side').html(html);
            }

            // rarity
            {
                let keys = ['Mythic', 'Rare', 'Uncommon', 'Common'];
                let raritys_main = {};
                let raritys_side = {};
                keys.forEach(key => {
                    raritys_main[key] = 0;
                    raritys_side[key] = 0;
                });

                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (d.type_line.includes('Basic')) {
                        return;
                    }
                    if (!d.sideboard) {
                        keys.forEach(key => {
                            if (key.toLowerCase() === d.rarity) {
                                raritys_main[key] += d.count;
                            }
                        });
                    } else {
                        keys.forEach(key => {
                            if (key.toLowerCase() === d.rarity) {
                                raritys_side[key] += d.count;
                            }
                        });
                    }
                });

                let html = '';
                html += '<table>';
                keys.forEach(key => {
                    html += '<tr>';
                    html += '<td style="text-align: right;">' + raritys_main[key] + '</td>';
                    html += '<td>' + key + '</td>';
                    html += '</tr>';
                });
                html += '</table>';
                $('#rarity_main').html(html);

                html = '';
                html += '<table>';
                keys.forEach(key => {
                    html += '<tr>';
                    html += '<td style="text-align: right;">' + raritys_side[key] + '</td>';
                    html += '<td>' + key + '</td>';
                    html += '</tr>';
                });
                html += '</table>';
                $('#rarity_side').html(html);
            }

            // price
            {
                let tix_main = 0;
                let usd_main = 0;
                let tix_side = 0;
                let usd_side = 0;
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (!d.sideboard) {
                        if (d.price_tix === null) {
                            tix_main = NaN;
                        } else {
                            tix_main += d.price_tix;
                        }

                        if (d.price_usd === null) {
                            usd_main = NaN;
                        } else {
                            usd_main += d.price_usd;
                        }
                    } else {
                        if (d.price_tix === null) {
                            tix_side = NaN;
                        } else {
                            tix_side += d.price_tix;
                        }

                        if (d.price_usd === null) {
                            usd_side = NaN;
                        } else {
                            usd_side += d.price_usd;
                        }
                    }
                });

                let html = '';
                html += '<table>';
                html += '<tr>';
                html += '<td>' + tix_main.toFixed(2) + ' Tix</td>';
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + usd_main.toFixed(2) + ' USD</td>';
                html += '</tr>';
                html += '</table>';
                $('#price_main').html(html);

                html = '';
                html += '<table>';
                html += '<tr>';
                html += '<td>' + tix_side.toFixed(2) + ' Tix</td>';
                html += '</tr>';
                html += '<tr>';
                html += '<td>' + usd_side.toFixed(2) + ' USD</td>';
                html += '</tr>';
                html += '</table>';
                $('#price_side').html(html);
            }

            // set
            {
                let sets = {};
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    if (d.type_line.includes('Basic')) {
                        return;
                    }
                    new Set(d.printings).forEach(set => {
                        sets[set] = (sets[set] || 0) + d.count;
                    });
                });
                let keys = Object.keys(sets);
                keys.sort((a, b) => sets[b] - sets[a]);
                if (keys.length > 3) {
                    keys.length = 3;
                }

                let html = '';
                html += '<table>';
                keys.forEach(key => {
                    html += '<tr>';
                    html += '<td style="text-align: right;">' + sets[key] + '</td>';
                    html += '<td>' + key.toUpperCase() + '</td>';
                    html += '</tr>';
                });
                html += '</table>';
                $('#set').html(html);
            }

            // format
            {
                let formats = {
                    paper: ['Standard', 'Explorer', 'Pioneer', 'Modern', 'Legacy', 'Vintage'],
                    paper_p: ['Pauper'],
                    arena: ['Alchemy', 'Historic'],
                    brawl: ['Brawl', 'HistoricBrawl', 'Commander'],
                    brawl_p: ['PauperCommander'],
                };
                let standard = {
                    m18: true,
                    m19: true,
                    m20: true,
                    m21: true,
                };
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    formats.paper = formats.paper.filter(key => d.legalities[key.toLowerCase()] === 'legal');
                    formats.paper_p = formats.paper_p.filter(key => d.legalities[key.toLowerCase()] === 'legal');
                    formats.arena = formats.arena.filter(key => d.legalities[key.toLowerCase()] === 'legal');
                    formats.brawl = formats.brawl.filter(key => d.legalities[key.toLowerCase()] === 'legal');
                    formats.brawl_p = formats.brawl_p.filter(key => d.legalities[key.toLowerCase()] === 'legal');

                    if (!['KLD', 'AER', 'AKH', 'HOU', 'XLN', 'RIX', 'DOM', 'M19'].some(set => d.printings.includes(set.toLowerCase()))) {
                        standard.m18 = false;
                    }
                    if (!['XLN', 'RIX', 'DOM', 'M19', 'GRN', 'RNA', 'WAR', 'M20'].some(set => d.printings.includes(set.toLowerCase()))) {
                        standard.m19 = false;
                    }
                    if (!['GRN', 'RNA', 'WAR', 'M20', 'ELD', 'THB', 'IKO', 'M21'].some(set => d.printings.includes(set.toLowerCase()))) {
                        standard.m20 = false;
                    }
                    if (!['ELD', 'THB', 'IKO', 'M21', 'ZNR', 'KHM', 'STX', 'AFR'].some(set => d.printings.includes(set.toLowerCase()))) {
                        standard.m21 = false;
                    }
                });

                let html = '';
                html += '<table>';
                if (commander) {
                    if (formats.brawl_p.length > 0) {
                        html += '<tr>';
                        html += '<td>' + formats.brawl_p.join(' / ') + '</td>';
                        html += '</tr>';
                        html += '<tr>';
                        html += '</tr>';
                    } else {
                        html += '<tr>';
                        html += '<td>' + formats.brawl.join(' / ') + '</td>';
                        html += '</tr>';
                        html += '<tr>';
                        html += '</tr>';
                    }
                } else {
                    if (formats.paper_p.length > 0) {
                        html += '<tr>';
                        html += '<td>' + formats.paper_p.join(' / ') + '</td>';
                        html += '</tr>';
                        html += '<tr>';
                        html += '</tr>';
                    } else {
                        html += '<tr>';
                        html += '<td>' + formats.paper.join(' / ') + '</td>';
                        html += '</tr>';
                        html += '<tr>';
                        html += '<td>' + formats.arena.join(' / ') + '</td>';
                        html += '</tr>';
                    }
                }

                html += '<tr>';
                html += '<td>';
                if (standard.m18) {
                    html += '(M18 Standard)';
                }
                if (standard.m19) {
                    html += '(M19 Standard)';
                }
                if (standard.m20) {
                    html += '(M20 Standard)';
                }
                if (standard.m21) {
                    html += '(M21 Standard)';
                }
                html += '</td>';
                html += '</tr>';
                html += '<table>';
                $('#format').html(html);
            }

            // keycard
            {
                let keymap = {
                    'Alrund\'s Epiphany': 'Epiphany',
                    'Approach of the Second Sun': 'Second Sun',
                    'Arclight Phoenix': 'Phoenix',
                    'Battle of Wits': 'Babel',
                    'Bolas\'s Citadel': 'Citadel',
                    'Casualties of War': 'Casualties',
                    'Cavalcade of Calamity': 'Cavalcade',
                    'Command the Dreadhorde': 'Dreadhorde',
                    'Crackling Drake': 'Drake',
                    'Doom Foretold': 'Doom',
                    'Dragon\'s Approach': '',
                    'Embercleave': 'Embercleave',
                    'Experimental Frenzy': 'Frenzy',
                    'Faceless Haven': 'Faceless Haven',
                    'Feather, the Redeemed': 'Feather',
                    'Feasting Troll King': 'Troll King',
                    'Felidar Guardian': 'Felidar',
                    'Field of the Dead': 'Field',
                    'Fires of Invention': 'Fires',
                    'Flood of Tears': 'Tears',
                    'Ghalta, Primal Hunger': 'Ghalta',
                    'God-Pharaoh\'s Gift': 'Gift',
                    'Goldspan Dragon': 'Dragon',
                    'Golos, Tireless Pilgrim': 'Golos',
                    'Greasefang, Okiba Boss': 'Greasefang',
                    'Happily Ever After': 'Happily Ever After',
                    'Hazoret the Fervent': 'Hazoret',
                    'Hero of Precinct One': 'Hero',
                    'Hinata, Dawn-Crowned': 'Hinata',
                    'Irencrag Pyromancer': 'Irencrag',
                    'Kenrith, the Returned King': 'Kenrith',
                    'Korvold, Fae-Cursed King': 'Korvold',
                    'Kroxa, Titan of Death\'s Hunger': 'Kroxa',
                    'Lich\'s Mastery': 'Lich',
                    'Lotus Field': 'Lotus',
                    'March of the Multitudes': 'March',
                    'Nexus of Fate': 'Nexus',
                    'Nicol Bolas, Dragon-God': 'Bolas',
                    'Nine Lives': 'Nine Lives',
                    'Nissa, Who Shakes the World': 'Nissa',
                    'Niv-Mizzet Reborn': 'Niv-Mizzet',
                    'Ob Nixilis, the Adversary': 'Nixilis',
                    'Oko, Thief of Crowns': 'Oko',
                    'Omnath, Locus of Creation': 'Omnath',
                    'Persistent Petitioners': 'Petitioners',
                    'Ramunap Ruins': 'Ramunap',
                    'Rat Colony': 'Rats',
                    'Relentless Rats': 'Rats',
                    'Sephara, Sky\'s Blade': 'Sephara',
                    'Scapeshift': 'Scapeshift',
                    'Shadowborn Apostle': 'Shadowborn',
                    'Teferi, Hero of Dominaria': 'Teferi',
                    'Thassa\'s Oracle': 'Oracle',
                    'Thousand-Year Storm': 'Thousand-Year Storm',
                    'Thud': 'Thud',
                    'Tibalt\'s Trickery': 'Tibalt\'s Trickery',
                    'Ugin, the Spirit Dragon': 'Ugin',
                    'Ulamog, the Ceaseless Hunger': 'Ulamog',
                    'Uro, Titan of Nature\'s Wrath': '',
                    'Yorvo, Lord of Garenbrig': 'Yorvo',
                    'Walking Ballista': 'Ballista',
                    'Wilderness Reclamation': 'Reclamation',
                    'Winota, Joiner of Forces': 'Winota',
                    'Witch\'s Oven': 'Oven',
                };
                let keycount = {};

                let keycards = [];
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }
                    let count = (keycount[d.name] || 0) + d.count;
                    keycount[d.name] = count;

                    if (commander) {
                        if (i === 0) {
                            keycards.push({
                                name: d.name,
                                image_uris: d.image_uris,
                            });
                        }
                    } else {
                        if (count >= 4) {
                            if (d.name in keymap) {
                                keycards.push({
                                    name: keymap[d.name],
                                    image_uris: d.image_uris,
                                });
                            }
                        }
                    }
                });

                let html = '';
                html += '<table>';
                keycards.forEach(d => {
                    html += '<tr>';
                    html += '<td><span class="key">' + d.name + '</span><img style="position: absolute; display: none;" alt="" src="' + d.image_uris.normal + '"></td>';
                    html += '</tr>';
                });
                html += '</table>';
                $('#keycard').html(html);
            }

            // decktype / supertype / subtype / keyword / archetype
            let super_types_count = {};

            let land_types_count = {};
            let creature_types_count = {};
            let permanent_types_count = {};
            let artifact_types_count = {};
            let enchantment_types_count = {};
            let spell_types_count = {};

            let keyword_count = {};

            let card_count = {
                anti_discard: [],

                self_mill: [],
                library_out: [],
                fog: [],
                looting: [],
                draw: [],
                self_discard: [],
                discard: [],
                ponza: [],
                permission: [],
                tron: [],
                post: [],
                mana_acceleration: [],
                direct_damage: [],
                reanimate: [],
                wrath: [],
            };

            let archetype_count = {
                legends: [],
                artifact: [],
                planeswalker: [],
                spells: [],
                instant: [],
                token: [],
                creature: [],
                weenie: [],
            };
            {
                data.forEach((d, i) => {
                    if (!d) {
                        return;
                    }

                    let type_temp = '';
                    let text_temp = '';
                    if (d.card_faces) {
                        if (!d.card_faces[0].type_line.includes('Land')) {
                            type_temp += ' ' + d.card_faces[0].type_line;
                            text_temp += ' ' + d.card_faces[0].oracle_text.split(d.card_faces[0].name).join('.');
                        }
                        if (!d.card_faces[1].type_line.includes('Land')) {
                            type_temp += ' ' + d.card_faces[1].type_line;
                            text_temp += ' ' + d.card_faces[1].oracle_text.split(d.card_faces[1].name).join('.');
                        }
                    } else {
                        if (!d.type_line.includes('Land')) {
                            type_temp = d.type_line;
                            text_temp = d.oracle_text.split(d.name).join('.');
                        }
                    }

                    // supertype
                    super_types.forEach(key => {
                        if (type_temp.includes(key)) {
                            if (!(key in super_types_count)) {
                                super_types_count[key] = [];
                            }
                            super_types_count[key].push(d);
                        }
                    });

                    // subtype land
                    land_types.forEach(key => {
                        if (text_temp.includes(key)) {
                            if (!(key in land_types_count)) {
                                land_types_count[key] = [];
                            }
                            land_types_count[key].push(d);
                        }
                    });

                    // subtype creature
                    let creature_type = false;
                    if (text_temp.includes('changeling') || text_temp.includes('choose a creature type')) {
                        creature_type = true;
                    }
                    creature_types.forEach(key => {
                        let target = creature_type;
                        if (type_temp.includes(key) || text_temp.includes(key)) {
                            target = true;
                        }
                        switch (key) {
                            case 'Dwarf':
                                if (type_temp.includes('Dwarves') || text_temp.includes('Dwarves')) {
                                    target = true;
                                }
                                break;
                            case 'Elf':
                                if (type_temp.includes('Elves') || text_temp.includes('Elves')) {
                                    target = true;
                                }
                                break;
                            case 'Wolf':
                                if (type_temp.includes('Wolves') || text_temp.includes('Wolves')
                                    || type_temp.includes('Werewolf') || text_temp.includes('Werewolf')
                                    || type_temp.includes('Werewolves') || text_temp.includes('Werewolves')) {
                                    target = true;
                                }
                                break;
                            case 'Werewolf':
                                target = false;
                                break;
                        }
                        if (target) {
                            if (!(key in creature_types_count)) {
                                creature_types_count[key] = [];
                            }
                            creature_types_count[key].push(d);
                        }
                    });

                    // subtype permanent
                    permanent_types.forEach(key => {
                        if (type_temp.includes(key) || text_temp.includes(key)) {
                            if (!(key in permanent_types_count)) {
                                permanent_types_count[key] = [];
                            }
                            permanent_types_count[key].push(d);
                        }
                    });
                    artifact_types.forEach(key => {
                        if (text_temp.includes(key)) {
                            if (!(key in artifact_types_count)) {
                                artifact_types_count[key] = [];
                            }
                            artifact_types_count[key].push(d);
                        }
                    });

                    // subtype enchantment
                    enchantment_types.forEach(key => {
                        if (text_temp.includes(key) ||
                            (key === 'Aura' && d.keywords.includes('Bestow'))) {
                            if (!(key in enchantment_types_count)) {
                                enchantment_types_count[key] = [];
                            }
                            enchantment_types_count[key].push(d);
                        }
                    });

                    // subtype spell
                    spell_types.forEach(key => {
                        if (text_temp.includes(key)) {
                            if (!(key in spell_types_count)) {
                                spell_types_count[key] = [];
                            }
                            spell_types_count[key].push(d);
                        }
                    });

                    type_temp = type_temp.toLowerCase();
                    text_temp = text_temp.toLowerCase();

                    // keyword ability
                    Object.keys(keyword_abilitys).forEach(key => {
                        let target = false;
                        if (text_temp.includes(key.toLowerCase())) {
                            target = true;
                        }
                        switch (key) {
                            case 'Exalted':
                                if (text_temp.includes('attacking alone') || text_temp.includes('attacks alone')) {
                                    target = true;
                                }
                                break;
                            case 'Storm':
                                if (text_temp.includes('copy it for each')) {
                                    target = true;
                                }
                                break;
                        }

                        if (keyword_abilitys[key].show) {
                            if (target) {
                                if (!(key in keyword_count)) {
                                    keyword_count[key] = [];
                                }
                                keyword_count[key].push(d);
                            }
                        }
                    });

                    // ability word
                    ability_words.forEach(key => {
                        let target = false;
                        if (text_temp.includes(key.toLowerCase())) {
                            target = true;
                        }
                        switch (key) {
                            case 'Heroic':
                                if ((text_temp.includes('whenever you cast') && text_temp.includes('that targets'))
                                    || text_temp.includes('becomes the target of a spell you control')) {
                                    target = true;
                                }
                                break;
                        }

                        if (text_temp.includes(key.toLowerCase())) {
                            if (!(key in keyword_count)) {
                                keyword_count[key] = [];
                            }
                            keyword_count[key].push(d);
                        }
                    });

                    // keyword action
                    keyword_actions.forEach(key => {
                        if (text_temp.includes(key.toLowerCase())) {
                            if (!(key in keyword_count)) {
                                keyword_count[key] = [];
                            }
                            keyword_count[key].push(d);
                        }
                    });

                    // keyword counter
                    if (text_temp.includes('+1/+1 counter')) {
                        let key = '+1/+1 counter';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('-1/-1 counter')) {
                        let key = '-1/-1 counter';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('{e}')) {
                        let key = 'Energy';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    // keyword batching
                    if (text_temp.includes('historic')) {
                        let key = 'Historic';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('modified')) {
                        let key = 'Modified';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('party')) {
                        let key = 'Party';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    // keyword other
                    if (text_temp.includes('devotion')) {
                        let key = 'Devotion';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }
                    if (text_temp.includes('roll a d20') || text_temp.includes('roll one or more dice')) {
                        let key = 'Dice rolling';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('you control an artifact and an enchantment')
                        || (text_temp.includes('you control an artifact') && text_temp.includes('you control an enchantment'))) {
                        let key = 'Harmony';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('whenever you draw your second card each turn')) {
                        let key = 'Second Draw';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('equal to its power')) {
                        let key = 'Biting';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    if (text_temp.includes('equal to its toughness') || text_temp.includes('backbone')) {
                        let key = 'Backbone';
                        if (!(key in keyword_count)) {
                            keyword_count[key] = [];
                        }
                        keyword_count[key].push(d);
                    }

                    // cardeffect
                    if (text_temp.includes('you to discard')) {
                        card_count.anti_discard.push(d);
                    }
                    if (text_temp.includes('put into your graveyard from your library')
                        || text_temp.includes('your library has no cards')
                        || text_temp.includes('dredge')) {
                        card_count.self_mill.push(d);
                    }
                    if (text_temp.includes('mill') || text_temp.includes('exiled cards with total mana value')) {
                        card_count.library_out.push(d);
                    }
                    if ((type_temp.includes('instant') && text_temp.includes('prevent all'))
                        || text_temp.includes('your life total can\'t change')
                        || text_temp.includes('your life total to less than 1')
                        || text_temp.includes('your life total would be reduced to 0')) {
                        card_count.fog.push(d);
                    }
                    if (text_temp.includes('draw ') || text_temp.includes('draws ')) {
                        if (text_temp.includes('discard')) {
                            card_count.looting.push(d);
                        } else {
                            card_count.draw.push(d);
                        }
                    } else if (text_temp.includes('discard')) {
                        if (text_temp.includes('opponent reveal') || text_temp.includes('player reveal') ||
                            text_temp.includes('opponent discard') || text_temp.includes('player discard')) {
                            card_count.discard.push(d);
                        } else {
                            card_count.self_discard.push(d);
                        }
                    }
                    if (text_temp.includes('destroy target land') || text_temp.includes('destroy target nonbasic land')
                        || (text_temp.includes('destroy target ') && text_temp.includes(' or land'))) {
                        card_count.ponza.push(d);
                    }
                    if (text_temp.includes('counter target') || text_temp.includes('counter that') || text_temp.includes('counter it')
                        || text_temp.includes('return target spell') || text_temp.includes('put target spell') || text_temp.includes('choose target spell') || text_temp.includes('owner of target spell')
                        || ((type_temp.includes('instant') || text_temp.includes('flash')) && (text_temp.includes('hexproof') || text_temp.includes('protection') || text_temp.includes('phase out') || text_temp.includes('phases out')))) {
                        card_count.permission.push(d);
                    }
                    if (d.type_line.includes('Urza\'s')) {
                        card_count.tron.push(d);
                    }
                    if (d.type_line.includes('Locus')) {
                        card_count.post.push(d);
                    }
                    if (text_temp.includes('add {')
                        || (text_temp.includes('add ') && text_temp.includes('mana'))
                        || ((text_temp.includes(' land') || text_temp.includes('forest')) && text_temp.includes('put'))
                        || (text_temp.includes('play') && text_temp.includes('additional land'))) {
                        card_count.mana_acceleration.push(d);
                    }
                    if ((text_temp.includes('deals') && (text_temp.includes('any target') || text_temp.includes('player') || text_temp.includes('opponent')))
                        || ((text_temp.includes('player loses') || text_temp.includes('opponent loses')) && text_temp.includes('life'))) {
                        card_count.direct_damage.push(d);
                    }
                    if (text_temp.includes('graveyard to the battlefield')
                        || (text_temp.includes('graveyard') && text_temp.includes('onto the battlefield under your control'))
                        || text_temp.includes('soulshift')) {
                        card_count.reanimate.push(d);
                    }
                    if (text_temp.includes('destroy all') || text_temp.includes('destroy each')
                        || text_temp.includes('exile all') || text_temp.includes('exile each')
                        || text_temp.includes('return all')
                        || text_temp.includes('sacrifices the rest')
                        || (text_temp.includes('each creature') || text_temp.includes('creatures') || text_temp.includes('creature tokens')) && (text_temp.includes('get -') || text_temp.includes('gets -'))
                        || (text_temp.includes('deals') && text_temp.includes('each creature'))) {
                        card_count.wrath.push(d);
                    }

                    // cardtype
                    if (text_temp.includes(' legendary card') || text_temp.includes('legendary permanent card')
                        || text_temp.includes('a legendary spell') || text_temp.includes('egendary spells')
                        || text_temp.includes('legendary creature')) {
                        archetype_count.legends.push(d);
                    }
                    if (type_temp.includes('artifact') || text_temp.includes('artifact creature token')
                        || text_temp.includes('fabricate')) {
                        archetype_count.artifact.push(d);
                    }
                    if (type_temp.includes('planeswalker') || text_temp.includes('planeswalker token')) {
                        archetype_count.planeswalker.push(d);
                    }
                    if (type_temp.includes('instant') || type_temp.includes('sorcery')) {
                        archetype_count.spells.push(d);
                    }
                    if (type_temp.includes('instant') || text_temp.includes('flash')) {
                        archetype_count.instant.push(d);
                    }
                    if (text_temp.includes('creature token')) {
                        archetype_count.token.push(d);
                    }
                    if (type_temp.includes('creature') || text_temp.includes('creature token')
                        || (text_temp.includes('land') && text_temp.includes('become') && text_temp.includes('creature'))) {
                        archetype_count.creature.push(d);
                        if (d.cmc < 3) {
                            archetype_count.weenie.push(d);
                        }
                    }
                });

                // supertype
                let html = '';
                html += '<table>';
                Object.keys(super_types_count).forEach(key => {
                    let count = super_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.06) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });
                html += '</table>';
                $('#supertype').html(html);

                // subtype
                html = '';
                html += '<table>';

                // subtype land
                Object.keys(land_types_count).forEach(key => {
                    let count = land_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.06) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });

                // subtype creature
                Object.keys(creature_types_count).forEach(key => {
                    let count = creature_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.20) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });

                // subtype permanent
                Object.keys(permanent_types_count).forEach(key => {
                    let count = permanent_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.20) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });
                Object.keys(artifact_types_count).forEach(key => {
                    let count = artifact_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.13) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });

                // subtype enchantment
                Object.keys(enchantment_types_count).forEach(key => {
                    let count = enchantment_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.13) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });

                // subtype spell
                Object.keys(spell_types_count).forEach(key => {
                    let count = spell_types_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.06) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });

                html += '</table>';
                $('#subtype').html(html);

                // keyword
                html = '';
                html += '<table>';
                Object.keys(keyword_count).forEach(key => {
                    let count = keyword_count[key].reduce((p, v) => p + v.count, 0);
                    if (count / counts_main >= 0.13) {
                        html += '<tr>';
                        html += '<td>' + key + '</td>';
                        html += '</tr>';
                    }
                });
                html += '</table>';
                $('#keyword').html(html);

                // archetype
                let aggro = false;
                let weenie = false;
                let burn = false;
                let ramp = false;
                let permission = false;
                let control = false;

                html = '';
                html += '<table>';

                // cardeffect
                if (card_count.anti_discard.reduce((p, v) => p + v.count, 0) / counts_main >= 0.06) {
                    html += '<tr>';
                    html += '<td>Anti Discard</td>';
                    html += '</tr>';
                }
                if (card_count.self_mill.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Self Mill</td>';
                    html += '</tr>';
                } else if (card_count.library_out.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Library Out</td>';
                    html += '</tr>';
                }
                if (card_count.fog.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    control = true;

                    html += '<tr>';
                    html += '<td>Fog</td>';
                    html += '</tr>';
                }
                if (card_count.looting.reduce((p, v) => p + v.count, 0) / counts_main >= 0.20) {
                    html += '<tr>';
                    html += '<td>Looting</td>';
                    html += '</tr>';
                }
                if (card_count.draw.reduce((p, v) => p + v.count, 0) / counts_main >= 0.20) {
                    html += '<tr>';
                    html += '<td>Card Advantage</td>';
                    html += '</tr>';
                }
                if (card_count.self_discard.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Self Discard</td>';
                    html += '</tr>';
                }
                if (card_count.discard.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Hand Destruction</td>';
                    html += '</tr>';
                }
                if (card_count.ponza.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Land Destruction</td>';
                    html += '</tr>';
                }
                if (card_count.permission.reduce((p, v) => p + v.count, 0) / counts_main >= 0.20) {
                    permission = true;
                    control = true;

                    html += '<tr>';
                    html += '<td>Permission</td>';
                    html += '</tr>';
                }
                if (card_count.tron.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    ramp = true;

                    html += '<tr>';
                    html += '<td>Tron</td>';
                    html += '</tr>';
                }
                if (card_count.post.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    ramp = true;

                    html += '<tr>';
                    html += '<td>Post</td>';
                    html += '</tr>';
                }
                if (card_count.mana_acceleration.reduce((p, v) => p + v.count, 0) / counts_main >= 0.26) {
                    ramp = true;

                    html += '<tr>';
                    html += '<td>Ramp</td>';
                    html += '</tr>';
                }
                if (card_count.direct_damage.reduce((p, v) => p + v.count, 0) / counts_main >= 0.26) {
                    burn = true;

                    html += '<tr>';
                    html += '<td>Burn</td>';
                    html += '</tr>';
                }
                if (card_count.reanimate.reduce((p, v) => p + v.count, 0) / counts_main >= 0.13) {
                    html += '<tr>';
                    html += '<td>Reanimate</td>';
                    html += '</tr>';
                }
                if (card_count.wrath.reduce((p, v) => p + v.count, 0) / counts_main >= 0.06) {
                    control = true;

                    html += '<tr>';
                    html += '<td>Control</td>'; // reset
                    html += '</tr>';
                }

                // cardtype
                if (archetype_count.legends.reduce((p, v) => p + v.count, 0) / counts_main >= 0.06) {
                    html += '<tr>';
                    html += '<td>Legends</td>';
                    html += '</tr>';
                }
                if (archetype_count.artifact.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    html += '<tr>';
                    html += '<td>Artifact</td>';
                    html += '</tr>';
                }
                if (archetype_count.planeswalker.reduce((p, v) => p + v.count, 0) / counts_main >= 0.20) {
                    html += '<tr>';
                    html += '<td>Superfriends</td>';
                    html += '</tr>';
                }
                if (archetype_count.spells.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    html += '<tr>';
                    html += '<td>Spells</td>';
                    html += '</tr>';
                }
                if (archetype_count.instant.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    html += '<tr>';
                    html += '<td>Flash</td>';
                    html += '</tr>';
                }
                if (archetype_count.token.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    html += '<tr>';
                    html += '<td>Token</td>';
                    html += '</tr>';
                }
                if (archetype_count.creature.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    aggro = true;

                    html += '<tr>';
                    html += '<td>Beatdown</td>';
                    html += '</tr>';
                }
                if (archetype_count.weenie.reduce((p, v) => p + v.count, 0) / counts_main >= 0.33) {
                    weenie = true;
                }

                html += '</table>';
                $('#archetype').html(html);

                // decktype
                let decktype = '???';
                if (aggro) {
                    if (control) {
                        decktype = 'Midrange';
                    } else if (permission) {
                        decktype = 'Clock Permission';
                    } else if (ramp) {
                        decktype = 'Stompy';
                    } else if (burn) {
                        decktype = 'Sligh';
                    } else if (weenie) {
                        decktype = 'Weenie';
                    } else {
                        decktype = 'Aggro';
                    }
                } else if (ramp) {
                    decktype = 'Ramp';
                } else if (control) {
                    decktype = 'Control';
                } else {
                    decktype = 'Combo';
                }
                $('#decktype').html(decktype);
            }

            // image
            {
                let html = '';
                data.forEach((d, i) => {
                    if (empty_row.includes(i)) {
                        html += '<hr style="height: 2px; background: #000000;">';
                    }
                    if (!d) {
                        return;
                    }

                    let flip = false;
                    if (d.card_faces) {
                        if (d.card_faces[0].image_uris) {
                            flip = true;
                        }
                    }

                    html += '<div style="display: inline-block; position: relative;">';
                    html += '<img style="position: absolute; z-index: -1; margin: 0; background: #E7E9EB;" alt="" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">';
                    html += '<span style="position: absolute; z-index: -1; margin: 4px; width: calc(100% - 8px); word-wrap: break-word;">' + d.name + '</span>';
                    html += '<div>';
                    if (flip) {
                        html += '<img alt="" src="' + d.card_faces[0].image_uris.normal + '" onerror="this.style.visibility = \'hidden\'">';
                        html += '<img alt="" src="' + d.card_faces[1].image_uris.normal + '" onerror="this.style.visibility = \'hidden\'" style="display: none;">';
                        html += '<p class="flip" style="position: absolute; margin: 5%; bottom: 7px; left: 38.25%; width: 20%; height: 14%; text-align: center; border-radius: 50%; background: white; cursor: pointer;"><span class="material-symbols-outlined" style="margin-top: 14%; pointer-events: none;">sync</span></p>';
                    } else {
                        html += '<img alt="" src="' + d.image_uris.normal + '" onerror="this.style.visibility = \'hidden\'">';
                    }
                    html += '</div>';
                    html += '<span style="position: absolute; margin: 5%; bottom: calc(7px + 5%); border-radius: 4px; width: 20%; height: 14%; text-align: center; font-weight: bold; background: white;">' + d.count + '</span>';
                    html += '</div>';
                });
                $('#board').html(html);

                resizeImage();
            }

            // Debuge
            console.log({
                data: data,
                color_symbols: symbols,
                archetype: {
                    supertype: super_types_count,
                    subtype_land: land_types_count,
                    subtype_creature: creature_types_count,
                    subtype_permanent: permanent_types_count,
                    subtype_spell: spell_types_count,
                    subtype_artifact: artifact_types_count,
                    subtype_enchantment: enchantment_types_count,
                    keyword: keyword_count,
                    decktype: archetype_count,
                },
            });
        }

        async function send(name, set, number) {
            return new Promise(async (resolve, reject) => {
                let ret = undefined;
                if (!ret && set) {
                    ret = await sendCardsSetNumber(set, number);
                }
                if (!ret && name) {
                    ret = await sendCardsNamed(name);
                }
                if (ret) {
                    let printings = await sendCardsPrints(ret);
                    if (printings) {
                        ret.printings = printings.data.map(d => d.set);

                        let tix = printings.data.filter(d => d.prices.tix !== null).map(d => Number(d.prices.tix));
                        let usd = printings.data.filter(d => d.prices.usd !== null).map(d => Number(d.prices.usd));
                        if (tix.length === 0) {
                            ret.price_tix = null;
                        } else {
                            ret.price_tix = Math.min(...tix);
                        }
                        if (usd.length === 0) {
                            ret.price_usd = null;
                        } else {
                            ret.price_usd = Math.min(...usd);
                        }
                    } else {
                        ret.printings = [ret.set];
                        ret.price_tix = ret.prices.tix;
                        ret.price_usd = ret.prices.usd;
                    }
                }
                resolve(ret);
            });
        }

        async function sendCatalogCreatureTypes() {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', 'https://api.scryfall.com/catalog/creature-types');
                request.onload = () => {
                    let data = JSON.parse(request.response);
                    if (data.object === 'catalog') {
                        resolve(data);
                    } else {
                        reject();
                    }
                };
                request.onerror = () => {
                    reject();
                };
                request.send();
            });
        }

        async function sendCardsSetNumber(set, number) {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', 'https://api.scryfall.com/cards/' + set.toLowerCase() + '/' + number);
                request.onload = () => {
                    let data = JSON.parse(request.response);
                    if (data.object === 'card') {
                        resolve(data);
                    } else {
                        resolve(undefined);
                    }
                };
                request.onerror = () => {
                    reject();
                };
                request.send();
            });
        }

        async function sendCardsNamed(name) {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', 'https://api.scryfall.com/cards/named?fuzzy=' + encodeURIComponent(name));
                request.onload = () => {
                    let data = JSON.parse(request.response);
                    if (data.object === 'card') {
                        resolve(data);
                    } else {
                        resolve(undefined);
                    }
                };
                request.onerror = () => {
                    reject();
                };
                request.send();
            });
        }

        async function sendCardsPrints(d) {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', d.prints_search_uri);
                request.onload = () => {
                    let data = JSON.parse(request.response);
                    if (data.object === 'list') {
                        resolve(data);
                    } else {
                        resolve(undefined);
                    }
                };
                request.onerror = () => {
                    reject();
                };
                request.send();
            });
        }
    </script>
</body>

</html>